"""
Markdown report renderer.

Generates a Markdown report suitable for documentation or GitHub.
"""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from spark_map.core.report import Report


def render_markdown(report: Report) -> str:
    """Render a report as Markdown."""
    lines = [
        f"# Spark Map Report",
        "",
        f"**Application:** {report.metrics.app_name or report.metrics.app_id}",
        f"**Generated:** {report.analysis_timestamp}",
        "",
        "---",
        "",
        "## Summary",
        "",
        f"| Metric | Value |",
        f"|--------|-------|",
        f"| Duration | {report.metrics.total_duration_ms / 1000:.1f}s |",
        f"| Stages | {report.metrics.num_stages} ({report.metrics.num_failed_stages} failed) |",
        f"| Tasks | {report.metrics.num_tasks} ({report.metrics.num_failed_tasks} failed) |",
        f"| Executors | {report.metrics.num_executors} |",
        f"| Total Input | {_format_bytes(report.metrics.total_input_bytes)} |",
        f"| Total Shuffle | {_format_bytes(report.metrics.total_shuffle_read_bytes + report.metrics.total_shuffle_write_bytes)} |",
        f"| Total Spill | {_format_bytes(report.metrics.total_disk_bytes_spilled)} |",
        "",
    ]

    # LLM Summary
    if report.llm_summary:
        lines.extend([
            "## AI Summary",
            "",
            f"> Generated by {report.llm_provider}",
            "",
            report.llm_summary,
            "",
        ])

    # Findings
    lines.extend([
        "## Findings",
        "",
    ])

    if not report.findings:
        lines.append("No performance issues detected.")
    else:
        lines.append(f"Found **{len(report.findings)}** issues:")
        lines.append("")

        for finding in report.findings.sorted_by_severity():
            severity_emoji = {
                "critical": "ðŸ”´",
                "warning": "ðŸŸ¡",
                "info": "ðŸ”µ",
            }.get(str(finding.severity), "âšª")

            stages = ", ".join(str(s) for s in finding.stage_ids) if finding.stage_ids else "N/A"

            lines.extend([
                f"### {severity_emoji} {finding.title}",
                "",
                f"**Severity:** {finding.severity.value.upper()}  ",
                f"**Stages:** {stages}  ",
                f"**Detector:** {finding.detector}",
                "",
                finding.description,
                "",
            ])

            if finding.llm_explanation:
                lines.extend([
                    "**AI Explanation:**",
                    f"> {finding.llm_explanation}",
                    "",
                ])

            lines.extend([
                f"**Suggestion:** {finding.mitigation_hint}",
                "",
                f"**Tags:** {', '.join(f'`{tag}`' for tag in finding.mitigation_tags)}",
                "",
                "---",
                "",
            ])

    # Stage Metrics Table
    lines.extend([
        "## Stage Metrics",
        "",
        "| Stage | Name | Tasks | Duration | Median | Max | Shuffle R | Shuffle W | Spill |",
        "|-------|------|-------|----------|--------|-----|-----------|-----------|-------|",
    ])

    for stage in report.metrics.stages:
        name = stage.stage_name[:30] + "..." if len(stage.stage_name) > 30 else stage.stage_name
        lines.append(
            f"| {stage.stage_id} | {name} | {stage.num_tasks} | "
            f"{stage.duration_ms / 1000:.1f}s | {stage.task_duration_median_ms}ms | "
            f"{stage.task_duration_max_ms}ms | {_format_bytes(stage.shuffle_read_bytes)} | "
            f"{_format_bytes(stage.shuffle_write_bytes)} | {_format_bytes(stage.disk_bytes_spilled)} |"
        )

    lines.extend([
        "",
        "---",
        "",
        "*Generated by [Spark Map](https://github.com/yourusername/spark-map)*",
    ])

    return "\n".join(lines)


def _format_bytes(num_bytes: int) -> str:
    """Format bytes as human-readable string."""
    if num_bytes == 0:
        return "0 B"
    for unit in ["B", "KB", "MB", "GB", "TB"]:
        if abs(num_bytes) < 1024.0:
            return f"{num_bytes:.1f}{unit}"
        num_bytes /= 1024.0
    return f"{num_bytes:.1f}PB"
